-- Minimal PoB Calculation Bootstrap
-- This file replaces HeadlessWrapper.lua with a minimal dependency chain
-- designed for headless calculation without GUI dependencies.

-- Get the PoB engine directory from package.path (set by Python)
local pob_src_dir = nil
for path in package.path:gmatch("[^;]+") do
    local dir = path:match("(.+)/Modules/%?%.lua")
    if dir then
        pob_src_dir = dir
        break
    end
end

if not pob_src_dir then
    error("[MinimalCalc] Could not determine PoB src directory from package.path")
end

print("[MinimalCalc] PoB src directory: " .. pob_src_dir)

-- Global stubs for missing PoB functions (minimal set)
local loaded_modules = {}

function LoadModule(path, ...)
    -- Simple LoadModule implementation that avoids GUI dependencies
    if loaded_modules[path] then
        return loaded_modules[path]
    end

    local file_path = path
    if not file_path:match("%.lua$") then
        file_path = file_path .. ".lua"
    end

    -- Try relative to PoB src directory first
    local full_path = pob_src_dir .. "/" .. file_path
    local func, err = loadfile(full_path)

    if not func then
        error("LoadModule() error loading '" .. path .. "': " .. tostring(err))
    end

    -- Pass all additional arguments to the module
    local args = {...}
    local result = func(...)
    loaded_modules[path] = result

    -- If first arg is a table and result is a table, merge them
    -- (This is how PoB's LoadModule works for data modules)
    local into_table = args[1]
    if type(into_table) == "table" and type(result) == "table" then
        for k, v in pairs(result) do
            into_table[k] = v
        end
    end

    return result
end

function PLoadModule(path, ...)
    local func, err = loadfile(path)
    if not func then
        error("PLoadModule() error loading '" .. path .. "': " .. tostring(err))
    end

    local status, result = pcall(func, ...)
    if not status then
        return result -- error message
    end

    return nil, result
end

-- Minimal stub for launch object (Common.lua expects this)
launch = {
    devMode = true  -- Always run in dev mode for headless
}

-- Stub out external library dependencies that Common.lua expects
-- These must be defined BEFORE loading Common.lua
print("[MinimalCalc] Creating stubs for external libraries and GUI functions...")

-- Directly inject modules into package.loaded to bypass require() mechanism
-- This avoids any C library loading that could crash

-- HTTP library stub (not needed for calculations)
package.loaded["lcurl.safe"] = {}

-- XML parser stub
package.loaded["xml"] = {
    parse = function(str) return {} end
}

-- Base64 encoding stub
package.loaded["base64"] = {
    encode = function(s) return s end,
    decode = function(s) return s end
}

-- SHA-1 hashing stub (returns identity function)
package.loaded["sha1"] = function(s) return s end

-- UTF-8 library stub (use LuaJIT's built-in utf8 if available)
package.loaded["lua-utf8"] = utf8 or {
    reverse = function(s) return s:reverse() end,
    gsub = string.gsub,
    find = string.find,
    sub = string.sub
}

-- Stub GUI functions that Common.lua and other modules might call
function GetCursorPos()
    return 0, 0  -- Return dummy cursor position
end

function GetTime()
    return os.clock() * 1000  -- Return milliseconds since start
end

-- Stub main object (referenced by Common.lua for formatting options)
main = {
    showThousandsSeparators = false,
    thousandsSeparator = ",",
    decimalSeparator = "."
}

-- Stub GlobalCache (referenced by Common.lua for skill caching)
GlobalCache = {
    cachedData = {
        MAIN = {},
        CALCS = {},
        CALCULATOR = {}
    }
}

print("[MinimalCalc] ===== STEP 1: Loading GameVersions.lua (pure data, no GUI) =====")
dofile(pob_src_dir .. "/GameVersions.lua")
print("[MinimalCalc] SUCCESS: latestTreeVersion = " .. latestTreeVersion)

print("[MinimalCalc] ===== STEP 2: Loading Common.lua (utility functions) =====")
LoadModule("Modules/Common")
print("[MinimalCalc] SUCCESS: Common.lua loaded, common.classes available")

-- STEP 3: Load minimal data constants (NOT full Data.lua which has GUI dependencies)
print("[MinimalCalc] ===== STEP 3: Loading Data/Global.lua (ModFlag, KeywordFlag, SkillType) =====")
dofile(pob_src_dir .. "/Data/Global.lua")
print("[MinimalCalc] SUCCESS: Global.lua loaded, ModFlag/KeywordFlag/SkillType available")

print("[MinimalCalc] ===== STEP 4: Loading Data/Misc.lua (game constants) =====")
-- Create data table for Misc.lua to populate
data = {}
LoadModule("Data/Misc", data)
print("[MinimalCalc] SUCCESS: Misc.lua loaded, data.characterConstants/gameConstants/monsterConstants available")

-- STEP 5: Load ModTools.lua (required by ModDB.lua which is used by Calcs.lua)
print("[MinimalCalc] ===== STEP 5: Loading Modules/ModTools.lua (modLib) =====")
modLib = {}
pcall(function()
    LoadModule("Modules/ModTools", modLib)
    print("[MinimalCalc] SUCCESS: ModTools.lua loaded, modLib available")
end)

-- STEP 6: Try loading calculation modules (Calcs.lua loads CalcSetup, CalcPerform, etc.)
print("[MinimalCalc] ===== STEP 6: Loading Modules/Calcs.lua (calculation engine) =====")
calcs = {}
pcall(function()
    LoadModule("Modules/Calcs", calcs)
    print("[MinimalCalc] SUCCESS: Calcs.lua loaded")
end)

print("[MinimalCalc] ===== Bootstrap complete - minimal PoB environment ready =====")

-- Expose Calculate function for Python to call
-- Story 1.5 Task 2: Full implementation
--
-- Input: buildData table with fields:
--   - characterClass: string (e.g., "Witch", "Warrior")
--   - level: number (1-100)
--   - passiveNodes: table/array of allocated passive node IDs
--   - ascendancyClass: string or nil (e.g., "Elementalist")
--
-- Output: table with calculated stats:
--   - TotalDPS: number
--   - Life: number
--   - EnergyShield: number
--   - Mana: number
--   - EHP: number (effective HP)
--   - FireResist: number
--   - ColdResist: number
--   - LightningResist: number
--   - ChaosResist: number
--   - Armour: number
--   - Evasion: number
--   - (additional stats as available)
--
function Calculate(buildData)
    print("[MinimalCalc] Calculate() called with buildData:")
    print("[MinimalCalc]   characterClass: " .. tostring(buildData.characterClass))
    print("[MinimalCalc]   level: " .. tostring(buildData.level))

    -- Validate input
    if not buildData or type(buildData) ~= "table" then
        error("[MinimalCalc] Calculate() requires buildData table parameter")
    end

    if not buildData.characterClass or not buildData.level then
        error("[MinimalCalc] buildData must have characterClass and level fields")
    end

    -- Construct minimal build object for PoB calculation engine
    -- This structure follows PoB's internal build representation
    local build = {}

    -- 1. Global data reference (loaded from Data/Misc.lua)
    build.data = data

    -- 2. Character data
    build.characterLevel = buildData.level
    build.characterClass = buildData.characterClass

    -- 3. Configuration tab (minimal settings)
    build.configTab = {
        input = {},  -- Empty config for MVP (use PoB defaults)
        placeholder = {}
    }

    -- 4. Passive tree spec (minimal structure)
    build.spec = {
        allocNodes = {},  -- Will be populated from buildData.passiveNodes
        tree = nil,       -- PassiveTree object (not available in minimal bootstrap)
        jewels = {}
    }

    -- Populate allocated passive nodes
    if buildData.passiveNodes and type(buildData.passiveNodes) == "table" then
        -- Convert Python list to Lua table
        for i, nodeId in ipairs(buildData.passiveNodes) do
            build.spec.allocNodes[nodeId] = true
        end
        print("[MinimalCalc]   allocated nodes: " .. #buildData.passiveNodes)
    else
        print("[MinimalCalc]   no passive nodes allocated")
    end

    -- 5. Items tab (empty for Story 1.5 scope)
    build.itemsTab = {
        items = {},
        activeItemSet = {
            -- Empty item set
        }
    }

    -- 6. Skills tab (empty for Story 1.5 scope)
    build.skillsTab = {
        skills = {},
        activeSkillGroup = 1
    }

    -- 7. Calculations tab
    build.calcsTab = {
        input = {}
    }

    print("[MinimalCalc] Build object constructed, calling calcs.initEnv()...")

    -- Check if calcs module loaded successfully
    if not calcs or not calcs.initEnv or not calcs.perform then
        error("[MinimalCalc] Calcs module not loaded or missing functions. Check PoB module loading.")
    end

    -- Initialize calculation environment
    -- calcs.initEnv() creates env.player and other calculation structures
    local success, env = pcall(function()
        return calcs.initEnv(build, "CALCULATOR")
    end)

    if not success then
        -- initEnv failed (likely due to missing data)
        print("[MinimalCalc] WARNING: calcs.initEnv() failed: " .. tostring(env))
        -- Return minimal stats (base character stats without calculations)
        return {
            TotalDPS = 0,
            Life = 100 + (buildData.level - 1) * 12,  -- Rough base life estimate
            EnergyShield = 0,
            Mana = 50 + (buildData.level - 1) * 6,    -- Rough base mana estimate
            EHP = 100 + (buildData.level - 1) * 12,
            FireResist = 0,
            ColdResist = 0,
            LightningResist = 0,
            ChaosResist = 0,
            Armour = 0,
            Evasion = 0
        }
    end

    print("[MinimalCalc] calcs.initEnv() successful, calling calcs.perform()...")

    -- Perform calculations
    -- calcs.perform() populates env.player.output with calculated stats
    success, err = pcall(function()
        calcs.perform(env)
    end)

    if not success then
        print("[MinimalCalc] WARNING: calcs.perform() failed: " .. tostring(err))
        -- Return minimal stats
        return {
            TotalDPS = 0,
            Life = 100 + (buildData.level - 1) * 12,
            EnergyShield = 0,
            Mana = 50 + (buildData.level - 1) * 6,
            EHP = 100 + (buildData.level - 1) * 12,
            FireResist = 0,
            ColdResist = 0,
            LightningResist = 0,
            ChaosResist = 0,
            Armour = 0,
            Evasion = 0
        }
    end

    print("[MinimalCalc] calcs.perform() successful, extracting results...")

    -- Extract calculated stats from env.player.output
    local output = env.player.output or {}

    -- Helper function to safely extract numeric values
    local function getNum(field, default)
        local value = output[field]
        if type(value) == "number" then
            return value
        end
        return default or 0
    end

    -- Construct result table
    local results = {
        -- Primary stats
        TotalDPS = getNum("TotalDPS"),
        Life = getNum("Life"),
        EnergyShield = getNum("EnergyShield"),
        Mana = getNum("Mana"),

        -- Effective HP (may not be directly available, calculate if needed)
        EHP = getNum("EHP", getNum("Life")),  -- Fallback to Life if EHP not available

        -- Resistances
        FireResist = getNum("FireResist"),
        ColdResist = getNum("ColdResist"),
        LightningResist = getNum("LightningResist"),
        ChaosResist = getNum("ChaosResist"),

        -- Defense stats
        Armour = getNum("Armour"),
        Evasion = getNum("Evasion"),

        -- Additional stats (if available)
        BlockChance = getNum("BlockChance"),
        SpellBlockChance = getNum("SpellBlockChance"),
        MovementSpeed = getNum("MovementSpeed")
    }

    print("[MinimalCalc] Calculation complete!")
    print("[MinimalCalc]   TotalDPS: " .. tostring(results.TotalDPS))
    print("[MinimalCalc]   Life: " .. tostring(results.Life))
    print("[MinimalCalc]   EnergyShield: " .. tostring(results.EnergyShield))
    print("[MinimalCalc]   Mana: " .. tostring(results.Mana))

    return results
end

print("[MinimalCalc] Bootstrap complete - Calculate() function exposed")
